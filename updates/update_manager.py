#!/usr/bin/env python3
#\"\"\"\nupdates/update_manager.py\n\nSimple, safe update manager for DEX Shell.\n\nFeatures:\n- Read local or remote manifest JSON\n- Compare versions / list available releases\n- Download patch ZIPs (streamed) and verify SHA256\n- Apply patch by extracting to target path with backup\n- Rollback using stored backup folders\n- Optional signature verification (requires 'cryptography' package)\n\nUsage examples:\n  python update_manager.py --manifest update_manifest.json --check\n  python update_manager.py --manifest https://example.com/update_manifest.json --apply patch-ui-20251101\n  python update_manager.py --rollback <backup-id>\n\nRequires: requests (for remote manifests & downloads)\nOptional: cryptography (for signature verification)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport hashlib\nimport json\nimport logging\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport time\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any\n\ntry:\n    import requests\nexcept Exception as e:\n    print(\"Missing dependency 'requests'. Install with: pip install requests\")\n    raise\n\n# Optional cryptography for signature verification\ntry:\n    from cryptography.hazmat.primitives import serialization, hashes\n    from cryptography.hazmat.primitives.asymmetric import padding\n    CRYPTO_AVAILABLE = True\nexcept Exception:\n    CRYPTO_AVAILABLE = False\n\n\nLOG = logging.getLogger('dex.update')\nLOG.setLevel(logging.INFO)\n_ch = logging.StreamHandler()\n_ch.setFormatter(logging.Formatter('[%(levelname)s] %(message)s'))\nLOG.addHandler(_ch)\n\n\n@dataclass\nclass Patch:\n    id: str\n    description: str\n    url: str\n    sha256: Optional[str]\n    size_bytes: Optional[int]\n    target_path: str\n    apply_mode: str = 'zip-merge'\n    pre_hook: Optional[str] = None\n    post_hook: Optional[str] = None\n    signature: Optional[str] = None  # optional signature URL or inline\n\n\nclass UpdateManager:\n    def __init__(self, manifest_source: str, repo_root: Optional[Path] = None):\n        self.manifest_source = manifest_source\n        self.repo_root = Path(repo_root or Path(__file__).resolve().parents[1]).resolve()\n        self.manifest = None\n        self.backups_dir = self.repo_root / 'updates_backups'\n        self.backups_dir.mkdir(exist_ok=True)\n\n    # -------------------------- Manifest loading --------------------------\n    def load_manifest(self) -> Dict[str, Any]:\n        LOG.info('Loading manifest: %s', self.manifest_source)\n        if self.manifest_source.startswith('http://') or self.manifest_source.startswith('https://'):\n            r = requests.get(self.manifest_source, timeout=15)\n            r.raise_for_status()\n            self.manifest = r.json()\n        else:\n            p = Path(self.manifest_source)\n            if not p.exists():\n                raise FileNotFoundError(f'Manifest not found: {p}')\n            with p.open('r', encoding='utf-8') as f:\n                self.manifest = json.load(f)\n        LOG.info('Manifest loaded: project=%s, release=%s', self.manifest.get('project'), self.manifest.get('current_release'))\n        return self.manifest\n\n    # -------------------------- Utilities --------------------------\n    @staticmethod\n    def hash_file_sha256(path: Path, chunk_size: int = 65536) -> str:\n        h = hashlib.sha256()\n        with path.open('rb') as f:\n            while True:\n                chunk = f.read(chunk_size)\n                if not chunk:\n                    break\n                h.update(chunk)\n        return h.hexdigest()\n\n    def download_patch(self, patch: Patch, dest_dir: Optional[Path] = None) -> Path:\n        dest_dir = Path(dest_dir or tempfile.mkdtemp(prefix='dex_patch_'))\n        LOG.info('Downloading patch %s -> %s', patch.id, dest_dir)\n        local_name = dest_dir / Path(patch.url).name\n\n        # stream download\n        with requests.get(patch.url, stream=True, timeout=30) as r:\n            r.raise_for_status()\n            with local_name.open('wb') as f:\n                for chunk in r.iter_content(chunk_size=8192):\n                    if chunk:\n                        f.write(chunk)\n        LOG.info('Downloaded to %s', local_name)\n\n        # verify size if provided\n        if patch.size_bytes and local_name.exists():\n            got = local_name.stat().st_size\n            if got != patch.size_bytes:\n                LOG.warning('Size mismatch: expected %s, got %s', patch.size_bytes, got)\n\n        # verify checksum\n        if patch.sha256:\n            LOG.info('Verifying SHA256...')\n            digest = self.hash_file_sha256(local_name)\n            if digest.lower() != patch.sha256.lower():\n                raise RuntimeError(f\"SHA256 mismatch for {local_name}: expected {patch.sha256}, got {digest}\")\n            LOG.info('SHA256 OK')\n\n        # optionally verify signature (if provided and cryptography available)\n        if patch.signature:\n            if not CRYPTO_AVAILABLE:\n                LOG.warning('Signature provided but cryptography not available. Skipping signature check.')\n            else:\n                LOG.info('Signature check requested but not implemented in this manifest example.')\n                # For production: fetch signature file and verify with public key\n\n        return local_name\n\n    # -------------------------- Apply / rollback --------------------------\n    def apply_patch_zip(self, zip_path: Path, patch: Patch) -> Dict[str, str]:\n        \"\"\"Apply a zip patch into target_path.\n\n        Strategy: create a backup (copy of target_path into timestamped folder),\n        extract zip into a temporary dir, then merge files into target_path.\n        Returns metadata with backup id info.\n        \"\"\"\n        import zipfile\n\n        LOG.info('Applying patch archive: %s', zip_path)\n        if patch.apply_mode not in ('zip-merge', 'zip-replace', 'script'):\n            raise ValueError('Unsupported apply_mode: ' + patch.apply_mode)\n\n        target = (self.repo_root / patch.target_path).resolve()\n        if not target.exists():\n            LOG.info('Target path does not exist; creating: %s', target)\n            target.mkdir(parents=True, exist_ok=True)\n\n        # create backup\n        ts = time.strftime('%Y%m%dT%H%M%S')\n        backup_id = f'{patch.id}_{ts}'\n        backup_path = self.backups_dir / backup_id\n        LOG.info('Creating backup to %s', backup_path)\n        shutil.copytree(str(target), str(backup_path))\n\n        # extract to temporary folder\n        tmp_extract = Path(tempfile.mkdtemp(prefix='dex_patch_extract_'))\n        try:\n            with zipfile.ZipFile(str(zip_path), 'r') as z:\n                z.extractall(str(tmp_extract))\n\n            if patch.apply_mode == 'zip-replace':\n                # remove target contents then move extracted\n                LOG.info('Applying zip-replace: clearing target folder then copying extracted content')\n                for child in target.iterdir():\n                    if child.is_dir():\n                        shutil.rmtree(child)\n                    else:\n                        child.unlink()\n                # copy extracted content\n                for item in tmp_extract.iterdir():\n                    dest = target / item.name\n                    if item.is_dir():\n                        shutil.copytree(str(item), str(dest))\n                    else:\n                        shutil.copy2(str(item), str(dest))\n\n            elif patch.apply_mode == 'zip-merge':\n                LOG.info('Applying zip-merge: merging files into target')\n                for root, dirs, files in os.walk(str(tmp_extract)):\n                    rel = os.path.relpath(root, str(tmp_extract))\n                    dest_dir = target / rel if rel != '.' else target\n                    dest_dir.mkdir(parents=True, exist_ok=True)\n                    for fname in files:\n                        src = Path(root) / fname\n                        dst = dest_dir / fname\n                        # back up existing file before overwrite (already done by full backup)\n                        shutil.copy2(str(src), str(dst))\n\n            elif patch.apply_mode == 'script':\n                LOG.info('Apply mode script: attempting to run patch script from archive root (patch.sh or patch.py)')\n                # attempt to find a script at top-level\n                candidates = ['patch.sh', 'patch.py', 'install.sh', 'install.py']\n                found = None\n                for c in candidates:\n                    p = tmp_extract / c\n                    if p.exists():\n                        found = p\n                        break\n                if not found:\n                    raise RuntimeError('No patch script found in archive')\n                # run script in temporary directory\n                if found.suffix == '.py':\n                    LOG.info('Running python patch script: %s', found)\n                    ret = os.system(f'\"{sys.executable}\" \"{str(found)}\"')\n                    if ret != 0:\n                        raise RuntimeError('Patch script failed: exit ' + str(ret))\n                else:\n                    LOG.info('Running shell patch script: %s', found)\n                    ret = os.system(f'bash \"{str(found)}\"')\n                    if ret != 0:\n                        raise RuntimeError('Patch script failed: exit ' + str(ret))\n\n            # post hook: run after apply\n            if patch.post_hook:\n                LOG.info('Executing post_hook: %s', patch.post_hook)\n                # security: only run relative scripts inside extracted archive\n                hook_path = tmp_extract / patch.post_hook\n                if hook_path.exists():\n                    if hook_path.suffix == '.py':\n                        os.system(f'\"{sys.executable}\" \"{str(hook_path)}\"')\n                    else:\n                        os.system(f'bash \"{str(hook_path)}\"')\n                else:\n                    LOG.warning('post_hook not found inside archive: %s', patch.post_hook)\n\n            LOG.info('Patch applied successfully. Backup id: %s', backup_id)\n            return {'status': 'ok', 'backup_id': backup_id, 'backup_path': str(backup_path)}\n\n        except Exception as exc:\n            LOG.error('Error applying patch: %s', exc)\n            LOG.info('Attempting rollback...')\n            # attempt rollback\n            try:\n                if backup_path.exists():\n                    if target.exists():\n                        shutil.rmtree(str(target))\n                    shutil.copytree(str(backup_path), str(target))\n                    LOG.info('Rollback complete')\n                else:\n                    LOG.error('No backup found to rollback')\n            except Exception as rerr:\n                LOG.error('Rollback failed: %s', rerr)\n            raise\n        finally:\n            # cleanup extracted temp folder\n            try:\n                shutil.rmtree(str(tmp_extract))\n            except Exception:\n                pass\n\n    def apply_patch(self, patch_dict: Dict[str, Any]) -> Dict[str, str]:\n        patch = Patch(\n            id=patch_dict.get('id'),\n            description=patch_dict.get('description', ''),\n            url=patch_dict.get('url'),\n            sha256=patch_dict.get('sha256'),\n            size_bytes=patch_dict.get('size_bytes'),\n            target_path=patch_dict.get('target_path', '.'),\n            apply_mode=patch_dict.get('apply_mode', 'zip-merge'),\n            pre_hook=patch_dict.get('pre_hook'),\n            post_hook=patch_dict.get('post_hook'),\n            signature=patch_dict.get('signature')\n        )\n\n        # pre-hook: (if present) we only allow pre-hooks inside archives, so we just download and then run pre-hook from extracted archive inside apply_patch_zip\n        local_archive = self.download_patch(patch)\n        if patch.apply_mode in ('zip-merge', 'zip-replace', 'script'):\n            return self.apply_patch_zip(local_archive, patch)\n        else:\n            raise RuntimeError('Unsupported apply mode')\n\n    def rollback(self, backup_id: str) -> bool:\n        backup_path = self.backups_dir / backup_id\n        if not backup_path.exists():\n            raise FileNotFoundError('Backup ID not found: ' + backup_id)\n        # target is repo root (dangerous to guess) â€” We require the caller to pass the target path to restore.\n        # For now we assume backup contains relative snapshot of repo root content; we will overwrite repo root.\n        target = self.repo_root\n        LOG.info('Restoring backup %s -> %s', backup_path, target)\n        # create additional staged backup in case restore fails\n        temp_save = self.backups_dir / (backup_id + '_prerestore_' + time.strftime('%Y%m%dT%H%M%S'))\n        LOG.info('Saving pre-restore snapshot to %s', temp_save)\n        shutil.copytree(str(target), str(temp_save))\n        # wipe target and copy backup\n        for item in target.iterdir():\n            if item == self.backups_dir:\n                continue\n            if item.is_dir():\n                shutil.rmtree(str(item))\n            else:\n                item.unlink()\n        for item in backup_path.iterdir():\n            dest = target / item.name\n            if item.is_dir():\n                shutil.copytree(str(item), str(dest))\n            else:\n                shutil.copy2(str(item), str(dest))\n        LOG.info('Rollback restore complete')\n        return True\n\n    # -------------------------- Convenience / CLI helpers --------------------------\n    def list_available_patches(self) -> Dict[str, Patch]:\n        if not self.manifest:\n            self.load_manifest()\n        patches = {}\n        for rel in self.manifest.get('releases', []):\n            for p in rel.get('patches', []):\n                patches[p['id']] = Patch(\n                    id=p['id'],\n                    description=p.get('description',''),\n                    url=p.get('url'),\n                    sha256=p.get('sha256'),\n                    size_bytes=p.get('size_bytes'),\n                    target_path=p.get('target_path','.'),\n                    apply_mode=p.get('apply_mode','zip-merge'),\n                    pre_hook=p.get('pre_hook'),\n                    post_hook=p.get('post_hook'),\n                    signature=p.get('signature')\n                )\n        return patches\n\n\n# -------------------------- CLI --------------------------\n\ndef main_cli():\n    parser = argparse.ArgumentParser(description='DEX Shell Update Manager')\n    parser.add_argument('--manifest', '-m', required=True, help='Local path or URL to update_manifest.json')\n    parser.add_argument('--check', action='store_true', help='Load manifest and print available releases/patches')\n    parser.add_argument('--apply', metavar='PATCH_ID', help='Apply a specific patch id listed in the manifest')\n    parser.add_argument('--rollback', metavar='BACKUP_ID', help='Rollback using backup id')\n    parser.add_argument('--list', action='store_true', help='List available patches (shorthand for --check)')\n    parser.add_argument('--repo-root', help='Repo root path (defaults to parent of updates/)', default=None)\n    args = parser.parse_args()\n\n    um = UpdateManager(args.manifest, repo_root=Path(args.repo_root) if args.repo_root else None)\n    um.load_manifest()\n\n    if args.check or args.list:\n        patches = um.list_available_patches()\n        if not patches:\n            print('No patches found in manifest')\n        else:\n            print('Available patches:')\n            for pid, p in patches.items():\n                print(f' - {pid}: {p.description} -> {p.url}')\n        return\n\n    if args.apply:\n        patches = um.list_available_patches()\n        if args.apply not in patches:\n            print('Patch id not found in manifest:', args.apply)\n            return\n        patch = patches[args.apply]\n        print('Applying patch:', patch.id)\n        try:\n            result = um.apply_patch({\n                'id': patch.id,\n                'description': patch.description,\n                'url': patch.url,\n                'sha256': patch.sha256,\n                'size_bytes': patch.size_bytes,\n                'target_path': patch.target_path,\n                'apply_mode': patch.apply_mode,\n                'pre_hook': patch.pre_hook,\n                'post_hook': patch.post_hook,\n                'signature': patch.signature\n            })\n            print('Apply result:', result)\n        except Exception as e:\n            print('Failed to apply patch:', e)\n        return\n\n    if args.rollback:\n        try:\n            ok = UpdateManager(args.manifest, repo_root=Path(args.repo_root) if args.repo_root else None).rollback(args.rollback)\n            print('Rollback success' if ok else 'Rollback failed')\n        except Exception as e:\n            print('Rollback error:', e)\n        return\n\n    parser.print_help()\n\n\nif __name__ == '__main__':\n    main_cli()\n```
